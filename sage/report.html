<html>
    <head><title>Report - SAGE</title></head>
    <body>
        <h1> Report </h1>
        <p>How we went about bringing our project to life.</p>
        <hr>
        <h2> Milestones </h2>
        <p>In general, we outpaced the milestones we set in our design document by quite a bit. In part, this is due to the existence of excellent frameworks and libraries, such as Google App Engine and jQuery, which made the implementation of a project of this scale much easier. Even when we had setbacks, such as scrapping Arbor.js in favor of our own graph layout engine, we were sufficiently ahead in other areas that our project as a whole was still on track. In general, the ordering of our milestones was accurate, but the amount of time we spent on each one varied somewhat from what we had imagined. For instance, we had the client and server communicating very quickly, but the graph layout took much longer because of unforeseen issues with Arbor.js. A somewhat expected trend in our milestones was that the further along they were in the project, the less accurately they reflected our actual progress or needs. For example, in week 7, we expected to implement prefetching from Microsoft for smoother browsing, but that ended up not being possible or feasible with the query limits imposed on us by Google and Microsoft. Instead, we ended up focusing on eliminating unnecessary queries and parallelizing our requests to the slow Microsoft Academic Search API. Overall, though, our milestones very closely defined the sequence in which we developed SAGE, if not the exact timeframe.</p>

        <hr>
        <h2> Organization </h2>
        <p>To kickstart the initial rapid development of SAGE, we originally split our code and team tasks into two groups: front-end and back-end. By working in parallel, particularly in the early stages of the project, we were able to build front-end features whose back-end implementation would be ready at the same time. Establishing a clear client-server interface and determining which client queries would result in which Microsoft queries, along with deciding which standards and protocols would be used, was key in enabling this parallel development. Logistically, frequent meetings were not entirely necessary for our group, but working together in person did accelerate development on the occasions when we did get together. Particularly, a fair amount of development occurred at the bi-weekly Code@Night event. In the later stages of the project, development shifted from multiple people working on the same feature in parallel to each person working on multiple features. This was a natural progression for our group, since each of us became more specialized as the features/bugs that were left to implement/fix became more numerous and more specific.</p>
<p>Bitbucket and git, the tools we used for code organization, both proved to be very helpful for development. Bitbucket provided a convenient web interface for looking at changes others had made, and a very useful issue tracker that we used heavily in the initial stages of the project to organize our tasks. Git provided all of the obvious benefits of a version control system, in addition to easily linking with Bitbucket, even though it presented a minor learning curve for some of our team members.</p>

        <hr>
        <h2> Learning the Material</h2>
        <p>Most of our team had some degree of web development experience, which definitely accelerated our progress throughout the semester. Half of our group did not have significant javascript experience, but because of its syntactic similarity to C and Java, this turned out not to be a cause for concern. The most significant new tool we learned about was jQuery, which was not difficult to learn but provided a wide variety of extremely useful functionality. We also had to learn the structure of a WSGI web server to implement our Appengine server. </p>
<p>Though not all of the tools were familiar to each of us, they were similar enough to tools we had used in the past that there wasn't a huge learning curve. The extensive documentation in the libraries we chose also helped: Google App Engine, for example, has a nice “Hello, world” tutorial to get new users started, and the jQuery documentation is extensive and clear. It's fair to say that we all expanded both the breadth and depth of our web-development knowledge, especially in the latter part of the semester, as we each became more specialized in a specific area of SAGE.</p>

        <hr>
        <h2>Surprises</h2>
        <p>Probably the biggest surprise we encountered was how unreliable Arbor.js was for the kinds of graphs we typically generated. Its particle system model did not do well with handling complex graphs with many interleaved edges; the graph would often flicker back-and-forth between two configurations. As such, we ended up implementing our own graph layout engine, which was not an entirely unplanned-for contingency, but was surprising nonetheless. We were also pleasantly surprised at how smoothly our graph layout engine development went - although it was not bug-free, it was mostly functional after only two nights of work and only required another day to port over the system from Arbor.js.</p>
        <p>The next biggest surprises were from the Microsoft Academic Search API - in particular, the query limit and latency. Microsoft imposes a 200 query/minute limit per API key, and in testing, we quickly realized that we would only be able to support a handful of users with this limit. In fact, we have hit this limit on multiple occasions when several of us were developing at the same time. This, combined with the several-second latency per query, meant we had to shift our optimization efforts towards minimizing the total number of API calls, and parallelizing those we did make. Fortunately, these efforts were largely successful, and our graph navigation is now relatively seamless.</p>
        <hr>
        <h2>Things we would do differently</h2>
        <p>In spite of our overall successful development pattern, there are a few things we would do differently if starting the project over. The main issue was poor modularity due to unforeseen complexity. The msquery.py module, while fully reliable and functional, was not designed with asynchronous queries in mind, which was simply an oversight on our part. Though we were able to retrofit it with asynchronous capabilities, the end result was not as clean as it might have been if designed that way from the ground up.</p>
        <p>Similarly, on the front-end, we continued to add to dcgtween.js as new issues and features came up, resulting in a functional but very messy implementation. This was mainly because we did not plan for the intricacies of the front-end ahead of time, but designed the UI as we went. Thus, graceful error handling, smooth animations, and event handling are often mixed up in code, especially in dcgtween.js.</p>
        <p>In general, as we got to the final week of the project, we encountered many small subtle bugs and blips in the smoothness user experience that turned out to be much more complicated than expected. Some of the fixes to these problems would drastically affect other features of the graph, requiring extensive rearranging of several functions. In the end, some of the rarer quirks were left in the interest of avoiding further complications.</p>
        <p>In addition, we could have made much better use of the Bitbucket issue tracker than we did. Although our team leader encouraged us to use the issue tracker religiously, the rest of the team never really got on board with it. We did make good use of it to list and organize tasks, especially in the beginning, but we probably should have made more of an effort to keep it up-to-date by actively creating, updating, and closing issues.</p>

        <hr>
        <h2>Future Development</h2>
        <p>We were able to implement all of our core functionality, but we have several ideas for future functionality that we didn't have the time or authority to implement.</p>
        <ul>
<li>Most significantly, for actual deployment and public usage, we would need a higher query-per-minute limit from Microsoft, or a different data source altogether, preferably one with a faster response time for the kinds of queries we frequently make, such as neighbor queries.</li>
<li>Another outstanding issue is cross-browser compatibility - our system works best in Chrome and Safari, passably in Firefox, and not at all in Internet Explorer. This would likely take a major effort to fix, as most of the problems are browser bugs or incompatibilities with CSS 3.</li>
<li>A less involved feature we have experimented with is having different-sized nodes based on number of citations. This would take advantage of another non-text variable, but we agreed that the inconsistent sizes lessened the impact of our system. Finding a good way to leverage this extra dimension would be very useful.</li>
<li>More abstractly, we would like to perform user studies of some sort to ensure that our system is as helpful as possible. We’d like to determine what information should and should not be displayed and in what fashion (e.g. can we make use of node sizes and coloring differently? what information should be displayed in the node tags?), as well as the number of nodes displayed (are the users getting enough context? is the screen too cluttered?).</li>
<li>We are also reliant on Microsoft’s ranking for search results, which may not always give the desired results. Finding a way to cluster results by relatedness, or even just providing ways to get a different set of results, might be a helpful feature to implement.</li>
<li>Persistent user accounts, in which users could save their tabs or queries, is another logical development. One idea mentioned in the Q&A of our presentation is that of curated collections; this could be tied in with user accounts, where users could select certain papers and see how they fit together in a graph, then share the results with other users.</li>
        </ul>
        <p>Overall, there are many directions this project could be taken in the future, and well all hope to see some of these ideas come to life as the project continues to grow.</p>
        <br><br>
    </body>
</html>

