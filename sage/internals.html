<html>
    <head><title>Internals - SAGE </title>
    </head>
    <body>
        <h1> Internals </h1>
        <h4> How SAGE works </h4>

        <hr>
        <h2> Server </h2>
        <p>The server is built using the Google App Engine (<a href="https://developers.google.com/appengine/">https://developers.google.com/appengine/</a>) framework in Python 2.7.  As such, the server can be run on any platform that App Engine and Python support, such as Windows, Mac, and Unix (all of which were used in the development of SAGE).  For production usage, however, the server is deployed on the App Engine servers, at <a href="http://sage-search.appspot.com">sage-search.appspot.com</a>.</p>
        <p>Organizationally, the server is divided into a series of Python modules that each handle a task for the server.  The main.py module is the communications hub: all client requests and server responses pass through the handlers defined in that module, and calls to other modules are all launched from there.  Each handler corresponds to a URL the user may request, such as '/' or  '/search', or to a URL the client-side Javascript may query for the graph functionality, such as '/fulltext' or '/neighbors'.  User-requested URLs return HTML pages prepared with the Jinja2 templating engine (included in Google App Engine), while programmatic communication between client and server is done via JSON.  When main.py receives a request for graph information, it uses a query module, such as msquery.py, to fulfill the request.  The query modules have a well-defined interface, however, so as to allow swapping of data sources.</p>
        <p>msquery.py is the interface between the main.py module and the Microsoft Academic Search (MSAS) API; all communication with Microsoft and processing of the results is performed there.  The basic interface that msquery.py exposes consists of a search query, metadata query, and neighbors query.  The search query performs a fulltext search by keyword, and populates the neighbors of each article in the list of results as a convenience.  The metadata query requests additional information about a specific article from Microsoft, and the neighbor query does the same, except the information returned is the articles that cite and are cited by the given article.  All articles are represented as objects of the article.py class, which contains fields for all of the information provided by Microsoft, such as title, authors, and references, and some utility functions, such as converting an article to JSON representation.</p>
        <p>All requests to Microsoft are asynchronous and parallelized to the extent that App Engine permits (typically 10 simultaneous requests).  The module async_urlfetch_manager.py handles this task with a queue data structure, where new URL fetches are launched as soon as old ones return.</p>
        <p>The encryption.py module handles cryptography for the MSAS API key, as the key should not be stored in plaintext on a third-party server.  The key is stored on disk in encrypted form, then decrypted at runtime by this module and loaded into memory.</p>
        <hr>
        <h2> Communication Scheme </h2>
        <p>There are three distinct entities that are involved in a SAGE search: the Microsoft Academic Search database, the SAGE server on Google App Engine, and the client in a browser. There are thus two network communications channels that we must be aware of (Microsoft database to Google App Engine and Google App Engine to the client). In case of network failure, our code is careful to differentiate which of these two links is down. </p>
        <ol>
            <li>On the client machine, the browser submits a search query from the homepage, issuing a /search request to our server. This is simply a GET HTML request with the query parameter in the url.</li>
            <li>On Google App Engine, the server renders a search result page that loads all of our javascript (but does not yet have any results) onto the client machine.</li>
            <li>On the client machine, once the page is completed loading, our code issues an asynchronous query to our server requesting the raw results for the search query (/fulltext). This is a POST HTML request.</li>
            <li>On Google App Engine, our server makes the full-text search query to Microsoft with the same text it was passed. Since we have no databases or systems of our own, we only need to perform rudimentary sanitization of input, relying on the robustness of Microsoft's server to handle any malicious attacks.</li>
            <li>Microsoft's database returns to us a list of results in JSON form. We request only a small number of the top results (currently 10).</li>
            <li>On Google App Engine, for each of these results, we issue a request for a list of all references in parallel. This involves sending Microsoft the specific ID of the paper that we wish to retrieve references for. We request all the references in order to ensure that the graph rendered by the client will be complete. We then combine the references into the search results and return a list of article objects in JSON form. Note that we only have the full information (title, author, year, etc.) for the primary search results - the set of neighbors for each result is only a list of IDs.</li>
            <li>On the client side, the JSON objects with complete reference (i.e. outedge) information is decoded and saved into the graph structure. Although not all neighbors of a node may be populated, having the full graph structure means that newly loaded nodes will still be correctly connected to existing nodes.</li>
            <li>On the client side, when the user clicks on a node that has not yet had its neighbors loaded, our code issues a request to our SAGE server (/neighbors) requesting neighbors of the node with the specified ID.</li>
            <li>On Google App Engine, we issue a request to Microsoft for the top neighbors of the requested article (not all of the neighbors).</li>
            <li>Microsoft's database returns to us the full information for these neighbors in JSON form.</li>
            <li>On Google App Engine, as with the search query we parallelize requests for the full reference list (by ID) of each of these results, combine the neighbor information with the article data, and return it to the client.</li>
        </ol>
        <hr>
        <h2> Client-side Scripts </h2>
        <p>There are several major client-side modules used by SAGE, all of which are written in Javascript with heavy usage of jQuery.  The most notable modules are the Dynamic Circular Grach, or DCG graph, layout class, implemented in dcg.js, and the node display manager, implemented in dcgtween.js. This structure was designed to maintain compatibility with the Arbor.js library that SAGE initially used. In the Arbor.js model, the main module (for us, dcg.js) would simply manage the graph data abstractly and, given a screen viewport, determine the locations at which nodes should be placed. The actual drawing of nodes was to be delegated to a separate class (for us, dcgtween.js), which has a function that is called every time the locations need to be updated (e.g. when the graph structure changes or when the browser resizes).</p>
        <p>The DCG class contains methods for managing the graph structure (adding and removing edges and nodes) and traversing the graph, as well as screen dimension configuration controls. The core of the class is the center() function, which calculates the point locations of the nodes. Our current implementation takes advantage of the fact that SAGE users will be focused on one node at a time; thus, we lay out one node in the center of the graph and arrange its direct neighbors in a circular fashion around it. This is the source of the name Dynamic Circular Graph.</p>
        <p>The dcgtween.js layout manager renders the graph and also manages user interaction with nodes. The core functionality of dcgtween is the display and animation of nodes and edges. In our implementation, nodes and edges are each their own separate div element, to facilitate event handling using jQuery. Our original implementation with Arbor.js used the HTML5 canvas element; both Arbor.js and dcg.js are agnostic to rendering choices. Note that our edge rendering relies on CSS3 transformations to display properly; this is the only source of browser compatibility issues (e.g. Firefox antialiases transforms poorly, whereas IE does not adhere to CSS3 standards). dcgtween also deals with adding event handlers to nodes as part of the element creation process. In addition, it must smoothly animate any changes in graph display or graph structure (since animation is not a part of dcg's responsibilities). As our system and interface have evolved, dcgtween.js has come to be rather bloated, and in the future it should be refactored.</p>
        <p>Interactive informational elements are also implemented in separate files: the behavior and content of the sidebar is mostly written in sidebar.js, and likewise the placement, content and hovering behavior of the tags for each node are in nodetext.js. The most significant tasks of these files are populating the contents of the elements from the node data, adding event handlers to enable user interaction such as clicks, and managing the display, positioning, and animation of the elements.</p>
        <p>As described above, we use the Jinja2 templating system to serve our raw html pages. Most of these are straightforward, as our contact, about, and home pages contain plain HTML. Our search results are served in two stages, however: the initial search query (/search) will first cause the server to render searchresult.html; then, once this page is finished loading (with all of our javascript), the page will populate itself with data by making an AJAX request to our server for query results (/fulltext).</p>
        <p>All of our node population and server interaction is handled in sagequery.js. The functions in this file mostly implement AJAX calls to the SAGE server, both for the initial results loading (/fulltext) and for neighbor queries (/neighbors) when navigating the graph. Other functions in this file populate the graph structure and the data for the node when the AJAX calls return.</p>
        <p>A couple of our UI elements, namely the tabs and the error dialog, are jQueryUI widgets. We also make use of the debounce jQuery extension to manage event firing rates. For both jQuery and jQueryUI, we access the scripts by linking to the Google CDN minified versions. For more information on the Google CDN hosting, see <a href="https://developers.google.com/speed/libraries/">https://developers.google.com/speed/libraries/</a></p>
        <br><br>
    </body>
</html>
