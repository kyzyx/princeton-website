<html>
    <head>
        <title>
            Kinect SDK C++ Tutorials - 0. Setup
        </title>
        <link rel="stylesheet" type="text/css" href="../main.css">
        <link href="../google-code-prettify/prettify.css" type="text/css" rel="stylesheet" />
        <script type="text/javascript" src="../google-code-prettify/prettify.js"></script>
    </head>
    <body onload="prettyPrint()">
    <div id='navbarcontainer'>
        <ul id='navbar'>
            <li class='navitem'><a class='nav' href='../../index.html'>Home</a></li>
            <li class='navitem'><a class='nav' href='../index.html'>Tutorials Home</a></li>
        </ul>
    </div>
    <div id='content'>
        <h1> Kinect SDK C++ - 1. Kinect Basics </h1>
        <p>
        <b>Goals:</b> Learn how to initialize a Kinect and get RGB data from it. <br>
        <b>Source:</b> <a href='https://github.com/downloads/kyzyx/Tutorials/1_Basics.zip'>1_Basics.zip</a>

        <hr>
        <h2>Overview</h2>
        We have two real pieces of Kinect-specific code. I will go over these
        in some detail, and give only a high level overview of the display
        code. 
        <hr>
        <h3> Includes </h3>
        <p> Mostly self explanatory. There are three header files for most
        Kinect uses, NuiApi, NuiImageCamera, and NuiSensor. 
        <p>You need to include Ole2.h and Windows.h for
        the Kinect includes to work correctly. Don't forget to include the
        relevant code for your windowing system and OpenGL.
        <table><tr><th>GLUT</th><th>SDL</th></tr><tr><td>
        <pre class="prettyprint">
#include &lt;Windows.h&gt;
#include &lt;Ole2.h&gt;

#include &lt;gl/GL.h&gt;
#include &lt;gl/GLU.h&gt;
#include &lt;gl/glut.h&gt;

#include &lt;NuiApi.h&gt;
#include &lt;NuiImageCamera.h&gt;
#include &lt;NuiSensor.h&gt;
        </pre></td><td>
        <pre class="prettyprint">
#include &lt;Ole2.h&gt;
#include &lt;Windows.h&gt;

#include &lt;SDL_opengl.h&gt;
#include &lt;SDL.h&gt;

#include &lt;NuiApi.h&gt;
#include &lt;NuiImageCamera.h&gt;
#include &lt;NuiSensor.h&gt;
        </pre></td></tr></table>

        <h3> Constants and Global Variables </h3>
        We define the width and height
        as 640*480, since these are the Kinect camera input dimensions. 
        <p> Note that the data array will hold a copy of the image we get
        from the Kinect, so that we can use it as a texture. Experienced 
        OpenGL users may want to use a Frame Buffer Object instead. 
        <pre class="prettyprint">
#define width 640
#define height 480

// OpenGL Variables
GLuint textureId;              // ID of the texture to contain Kinect RGB Data
GLubyte data[width*height*4];  // BGRA array containing the texture data

// Kinect variables
HANDLE rgbStream;              // The identifier of the Kinect's RGB Camera
INuiSensor* sensor;            // The kinect sensor
        </pre>

        <hr>
        <h3>Kinect Initialization</h3>

        This is our first real Kinect-specific code. The 
        <code>initKinect()</code> function initializes a Kinect sensor for use.
        This consists of two parts: First we find an attached Kinect sensor,
        then we initialize it and prepare to read data from it. <p>
        <pre class="prettyprint">
bool initKinect() {
    // Get a working kinect sensor
    int numSensors;
    if (NuiGetSensorCount(&numSensors) < 0 || numSensors < 1) return false;
    if (NuiCreateSensorByIndex(0, &sensor) < 0) return false;

    // Initialize sensor
    sensor->NuiInitialize(NUI_INITIALIZE_FLAG_USES_DEPTH | NUI_INITIALIZE_FLAG_USES_COLOR);
    sensor->NuiImageStreamOpen(
        NUI_IMAGE_TYPE_COLOR,            // Depth camera or rgb camera?
        NUI_IMAGE_RESOLUTION_640x480,    // Image resolution
        0,      // Image stream flags, e.g. near mode
        2,      // Number of frames to buffer
        NULL,   // Event handle
        &rgbStream);
    return sensor;
}
        </pre>
        Things to note:
        <ul>
            <li>Normally, we'd be a bit more careful about return values for 
            all of these functions, and also handle the case where there is 
            more than one Kinect sensor available; however, for brevity we will
            just try to use the first connected kinect sensor. </li>
            <li>The <code>NuiInitialize</code> method takes a bunch of flags
            specifying which sensor features you are interested in. Right now,
            we choose the color and depth camera inputs; there are also options
            for audio input and skeleton input, among others. See the 
            <a href='http://msdn.microsoft.com/en-us/library/hh855368#NUI_INITIALIZE'>official API</a> for more details.</li>
            <li>The <code>NuiImageStreamOpen()</code> method is a little
            confusing. It initializes a <code>HANDLE</code> that we can later
            use to get image frames. This function can be used either to set up
            an RGB color image stream or a depth image stream (based on the 
            first argument). You can ignore the 3rd and 5th arguments for now. 
            Keep the resolution as 640x480 and the buffer size some single
            digit number. The last argument is a pointer to the 
            <code>HANDLE</code> that we'll use to actually get image frames. 
            See the <a href='http://msdn.microsoft.com/en-us/library/nuiimagecamera.nuiimagestreamopen'>documentation</a> for more details.
            </li>
        </ul>
        <h3> Getting an RGB frame from the Kinect </h3>
        To actually get a frame from the sensor, we have to fetch it and lock it
        so it doesn't get corrupted while we're reading it. 
        <pre class="prettyprint">
void getKinectData(GLubyte* dest) {
    NUI_IMAGE_FRAME imageFrame;
    NUI_LOCKED_RECT LockedRect;
    if (sensor->NuiImageStreamGetNextFrame(rgbStream, 0, &imageFrame) < 0) return;
    INuiFrameTexture* texture = imageFrame.pFrameTexture;
    texture->LockRect(0, &LockedRect, NULL, 0);
        </pre>
        There are three types in this short snippet:
            <code>NUI_IMAGE_FRAME</code> is a structure containing all the
            metadata about the frame - the number, resolution, etc.
            <code>NUI_LOCKED_RECT</code> contains a pointer to the actual data.
            An <code>INuiFrameTexture</code> manages the frame data.
        So first we acquire a <code>NUI_IMAGE_FRAME</code> from the
        <code>HANDLE</code> we initialized earlier. Then we get an
        <code>INuiFrameTexture</code> so that we can get the pixel data out
        of it, using a <code>NUI_LOCKED_RECT</code>.
        <br>
        Now, we can copy the data to our own memory location.
        <pre class="prettyprint">
    if (LockedRect.Pitch != 0)
    {
        const BYTE* curr = (const BYTE*) LockedRect.pBits;
        const BYTE* dataEnd = curr + (width*height)*4;

        while (curr &lt; dataEnd) {
            *dest++ = *curr++;
        }
    }
        </pre>
        The Kinect data is in BGRA format, so we can copy it directly
        into our buffer and use it as an OpenGL texture. 
        <br>
        Finally, we have to release the frame so that the Kinect can use it
        again.
        <pre class="prettyprint">
    texture->UnlockRect(0);
    sensor->NuiImageStreamReleaseFrame(rgbStream, &imageFrame);
}
        </pre>

        Things to note:
        <ul>
            <li> Again, we aren't checking return codes on everything. You may
            want to do this in your applications </li>
            <li> If you're calling this update function too quickly, then
            the Kinect might not have a new frame that you haven't seen yet. In
            this case, <code>NuiImageStreamGetNextFrame()</code> will return a
            negative value. 
            The second argument of <code>NuiImageStreamGetNextFrame()</code>
            specifies how long to wait (in milliseconds) for a new frame before
            returning failure.
            </li>
            <li> The workflow is as follows:
            <ol>
            <li>Acquire a frame: <code>sensor->NuiImageStreamGetNextFrame()</code>. 
            The first parameter is the <code>HANDLE</code> we initialized 
            earlier, and the last is a pointer to a <code>NUI_IMAGE_FRAME</code>
            struct that will contain the frame data. The second argument allows 
            you to wait for a frame if a new one is not ready (see above)</li>
            <li>Lock the pixel data: <code>imageFrame.pFrameTexture->LockRect()</code>. All the arguments must be 0 or NULL except for the second, which is
            a pointer to a <code>NUI_LOCKED_RECT</code> struct.</li>
            <li>Copy the data (from <code>LockedRect.pBits</code>)</li>
            <li>Unlock the pixel data: <code>imageFrame.pFrameTexture->UnlockRect()</code>. Argument must be 0</li>
            <li>Release the frame: <code>sensor->NuiImageStreamReleaseFrame()</code>. First argument is the image stream <code>HANDLE</code>, second is a
            pointer to the image frame that we are releasing</li>
            </ol>
            </li>
        </ul>
        <br>
        That's all the Kinect code! The rest is just how to get it onscreen.
        <hr>
        <h3> Window Initialization </h3>
        The initialization code is specific to which implementation (SDL or
        GLUT) is used. It simply initializes a window using the appropriate
        API, returning false on failure. The GLUT version also sets up a
        main loop.
        <table><tr><th>GLUT</th><th>SDL</th></tr><tr><td>
        <pre class="prettyprint">
void draw(void);

bool init(int argc, char* argv[]) {
    glutInit(&amp;argc, argv);
    glutInitDisplayMode(GLUT_DEPTH | GLUT_DOUBLE | GLUT_RGBA);
    glutInitWindowSize(width,height);
    glutCreateWindow("Kinect SDK Tutorial");
    glutDisplayFunc(draw);
    glutIdleFunc(draw);
    return true;
}
        </pre></td><td>
        <pre class="prettyprint">
bool init(int argc, char* argv[]) {
    SDL_Init(SDL_INIT_EVERYTHING);
    SDL_Surface* screen = SDL_SetVideoMode(width, height, 32, SDL_HWSURFACE | SDL_GL_DOUBLEBUFFER | SDL_OPENGL);
    return screen;
}
        </pre></td></tr></table>
        <hr>
        <hr>
        <p align="right">
        <a href='#'>Next: Kinect Depth Data (Coming Soon)</a>
        </p>
    </div>
    </body>
</html>
