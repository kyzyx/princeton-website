<html>
    <head>
        <title>Edward Zhang - COS526 Assignment 3 - Photon Mapping</title>
    </head>
    <body>
        <h1> COS526 Fall 2012 - Assignment 3: Photon Mapping </h1>
        <h2> Edward Zhang (edwardz)</h2>
        Photon Maps are an extension to Monte Carlo methods for ray tracing. They provide
        an effective way to get global illumination effects (such as diffuse color bleeding) and caustics (such as a glass object focusing light) that are extremely
        difficult to simulate with standard ray-tracing. <br>This is accomplished by casting photons out from the lights in the scene and storing them on diffuse surfaces, and then using these photons to supplement standard Monte-Carlo raytracing lighting calculations.

        <!-- ############################################################# -->
        <h2>Photons</h2>
        The photon data structure has the following fields:
        <ul>
            <li><code>R3Point pos</code>: The position of the photon</li>
            <li><code>RNRgb power</code>: The power of the photon, in RGB</li>
            <li><code>R3Point direction</code>: The direction that the photon came from</li>
        </ul>
        There are also two debugging fields that are used for visualization
        <ul>
            <li><code>R3Point from</code>: The point that this photon came from (a light or a surface) </li>
            <li><code>char type</code>: Whether the photon was emitted directly or produced from a specular, diffuse, or transmissive intersection</li>
        </ul>
        <h2>Photon Tracing</h2>
            There are several distinct steps in photon tracing.
            <ol>
                <li><b>Photon Emission</b>: First of all, we generate photons from all the light sources in the image. The number of photons is set as a command line parameter. The number of photons emitted from each light source is proportional to the light source intensity.
                <br>
                Since each different light type works differently, there has to be a different photon emission step for each light type. I implemented this in the emitphotons.cpp file.
                <br>
                There are several interesting things to note about photon emission. First of all, there were two common functions that were used in multiple cases: one was to generate a random point on a circle, which was simply done using rejection sampling in the unit square. The other was to generate a random vector weighted by the cosine of the angle from a direction, which was done simply by uniformly sampling points on a sphere by phi and theta
                <br>
                Area lights use the above two functions to generate the position and direction, respectively.
                Point lights were uniformly sampled from points on a sphere by inverse sampling. Spotlight photons were sampled according to the cosine distribution function, as above.

                <br>
                Directional lights cause a bit of a headache because the effective power (relative to other lights) is dependent on the scene geometry. I did not choose to deal with this in any special way; powers were just set to be intensity divided by number of photons, just as for other lights. Photon positions were simply generated by generating a plane outside the bounding box of the scene. This plane was chosen to be perpendicular to the direction and tangent to the appropriate corner of the bounding box. Then, each other corner on the bounding box was projected onto the plane and points were uniformly sampled in the bounding circle of those projections.
                </li>
                <li>
                    <b>Photon Scattering, BRDF Importance Sampling, and Russian Roulette</b>
                    There are two utility functions used in scattering and russian roulette. The first is
                    a RotateToVector function, which is used in BRDF Importance Sampling. This function takes a vector that is generated according to some distribution relative to the x-axis vector, and then
                    transforms it so that it is relative to some other vector.

                    <br>
                    The other utility function actually performs scattering and russian roulette, and is
                    also used by the raytracing renderer. This Trace function first calculates the appropriate
                    diffuse, specular, and transmissive powers and probabilities, according to Jensen01. Then, it randomly determines whether to reflect the incoming light (photon or ray) in a transmissive, specular, or diffuse manner according to these probabilities. I assumed that refracted rays would always undergo perfect refraction, but specular and diffuse rays were sampled according to the BRDF as specified in Jason Lawrence's course notes.
                    Note that this function also must move the generated position a little bit off of the intersecting surface; otherwise floating point error will often cause subsequent traces to intersect the same spot.

                    <br>
                    To actually perform photon scattering, we iterate over all the emitted photons, determine if they intersect the scene, and call Trace on them if so to determine the appropriate values for a newly generated photon (or do not generate a photon if the photon is absorbed). The photons are recursively traced if appropriate, and the old photon stored if the intersecting material is diffuse.
                    <br>
                    A significant downside of the provided scene files is that materials do not necessarily conform to the conservation of energy constraint that the sum of the specular, diffuse, and transmissive coefficients are less than one. This causes significant problems for russian roulette, since a trace would never terminate. Therefore, I included a parameter to the Trace function that specifies an absorption probability (default 0.05). By scaling the diffuse, transmissive, and specular coefficients appropriately, this ensured that the trace would eventually terminate.

                    <br>
                    <img src="output/roulette.jpg"><br>
                    This is a visualization of the russian roulette process in the still life scene. Notice that one path actually underwent many diffuse (cyan) and specular (magenta) reflections before terminating.
                </li>
                <li>
                    <b>Photon Storage</b>
                    Through the scattering process, photons are continually added to an array when they
                    are stored. There are two arrays used; one for the global map and one for the caustic
                    map. These arrays are used to construct photon map KD Trees after scattering has
                    been completed.
                </li>
                <li>
                <b>Multiple Photon Maps</b>: Although the global illumination map deals with caustics
                fairly well, there are many cases where a supplemental caustic photon map helps a lot.
                My implementation allows the user to specify whether a caustic map is desired; a caustic
                map will emit many more photons than the global photon map emission (but will keep fewer of them). In the example below, you can see the difference in effect that the caustics make, especially directly behind the cube.
                <table>
                    <tr>
                        <td>
                            <img src="output/direct.jpg">
                        </td>
                        <td>
                            <img src="output/caustic.jpg">
                        </td>
                    </tr>
                    <tr>
                        <td>
                            Jello Cube with Global Illumination Photon Map
                        </td>
                        <td>
                            Jello Cube with Caustic Photon Map and Global Map
                        </td>
                    </tr>
                    <tr>
                        <td>
                            <code>src/photonmap input/prism.scn output/caustic.jpg -resolution 200 200 -n 2000000 -r 500</code>
                        </td>
                        <td>
                            <code>src/photonmap input/prism.scn output/caustic.jpg -resolution 200 200 -n 2000000 -r 500 -caustic</code>
                        </td>
                    </tr>
                </table>
                </li>
                <li>
                <b>Photon Map Visualization</b>: Since I had many odd errors earlier on, I implemented
                a number of ways to visualize the photons in my photon map. One that I used for large
                numbers of photons was a photon density map, where the intensity of each pixel was proportional to the number of photons in the map that would be projected onto that pixel. This helped me make sure photons were going where I thought they should (you can see the effect of the caustics below).
                <br>
                <table> <tr> <td>
                <img src="output/photondensity.bmp">
                </td></tr><tr><td>
                Cornell Box Photon Density Map
                </td></tr></table>
                <br>
                Another visualization that I used heavily visualized not only the photons, but the paths
                they came from. This used the optional fields in the Photon data structure, and rendered
                the paths using cylinders of different colors. This system is totally unusable with any more than several hundred photons, however.
                <table> <tr> <td>
                <img src="output/visualize.jpg">
                </td><td><img src="output/visualize2.jpg"></td></tr><tr><td>
                Cornell Box Photon Visualization
                </td><td> Still Life Photon Visualization </td></tr></table>
                </li>
            </ol>
        <hr>
        <!-- ############################################################# -->
        <h2>Radiance Estimation at a Point</h2>
        Radiance estimation at a point includes three components: direct lighting, radiance from photon maps, and ray tracing.
        <ul>
            <li>Direct lighting casts a shadow ray (or multiple shadow rays, for area lights) to determine visibility to each light, and then performs the appropriate lighting calculation (code taken from my implementation of cos426 ray tracer).</li>
            <li>Photon Mapping uses the global (and caustic) photon maps to determine the lighting at each point. We use the formula from Jensen03 (without filtering) to estimate radiance at each point, and add it to the direct lighting calculation and Monte Carlo path tracing results. </li>
            <li> Monte Carlo Path Tracing uses the same code for scattering photons (with appropriate probabilities for specular reflection, transmission, or diffuse reflection, including Russian Roulette). </li>
        </ul>
        Note that the first bounce of a photon is never stored at diffuse surfaces, since that component
        is included in the direct lighting calculation.
        <table>
            <tr>
                <td>
                    <img src="output/directlighting.jpg">
                </td>
                <td>
                    <img src="output/montecarlo.jpg">
                </td>
                <td>
                    <img src="output/all.jpg">
                </td>
            </tr>
            <tr>
                <td>
                    Direct Lighting Only
                </td>
                <td>
                    Monte Carlo Path Tracing (with russian roulette) and Direct Lighting
                </td>
                <td>
                    Photon Map, Direct Lighting, and Path Tracing<br>
                    500000 photons, 200 nearest photons
                    <br>
                    <code>src/photonmap input/cornell.scn output/all.jpg -resolution 300 300 -n 500000 -r 200</code>

                </td>
            </tr>
            <tr>
                <td>
                    <img src="output/p50.jpg">
                </td>
                <td>
                    <img src="output/p200.jpg">
                </td>
                <td>
                    <img src="output/caustic.jpg">
                </td>
            </tr>
            <tr>
                <td>
                    50 Photon Neighborhood
                </td>
                <td>
                    200 Photon Neighborhood
                </td>
                <td>
                    500 Photon Neighborhood
                </td>
            </tr>
        </table>
        We can see the results of having various photon neighborhood sizes (number of nearest neighbors) in the images above. In the caustics in the shaded region, we see a speckled pattern with
        fewer photons in the neighborhood (also appears in the cornell box), but with more photons in the neighborhood the caustics become much smoother.

        <hr>
        <h2>Rendering (Camera Ray Tracing, Pixel Integration/Multisampling)</h2>
        To render an entire image, I generate some number of rays within each pixel for antialiasing (default 3, which is what all images here are rendered with). Each of these rays is then tested for scene intersection, then rendered according to the radiance estimation described above. Finally, some scaling needs to be done so that pixels have valid values (0-255 RGB). Via a combination of adjusting light parameters and scaling such that pixels too far above the mean value were clamped, I managed to get acceptable results. This can actually be observed in the above set of images; note that the images without global illumination appear overall brighter, whereas the only
        really bright spot in the photon mapped image is the caustic under the sphere.

        <br>
        My scaling decision was somewhat arbitrary, but it meant that tuning lighting parameters was easier since I could see most of the range of variance in the illumination. I'd probably let more clamping happen if I were trying to go for the best appearance.
        <hr>
        <h2>Sample Image Results</h2>
        The most interesting effects obtainable with photon maps are diffuse interreflection and
        caustics. I created my own simple scene of a red "jello" cube on a table to look at caustic effects, and
        the default cornell box has a great demonstration of diffuse interreflection near the back walls.
        <table>
            <tr>
                <td>
                    <img src="output/caustic.jpg">
                </td>
                <td>
                    <img src="output/all.jpg">
                </td>
            </tr>
            <tr>
                <td>
                    Jello Cube showing Caustics
                </td>
                <td>
                    Cornell Box showing interreflection
                </td>
            </tr>
        </table>
        <hr>
        General Observations about the project:
        <ul>
            <li> There is a lot of code in the library! Nice in some ways, tedious in others </li>
            <li> The most frustrating part is balancing the lighting parameters. I had to do a lot
            of hand tuning of intensities and attenuation paramaters, as well as make some arbitrary
            weighting and scaling decisions for aesthetic sense. If this project is to be used in the
            future, it would be nice to have a standard way of dealing with power and maybe some sample scenes.</li>
            <li>Some kind of simple CAD scene designer would be really nice (for 426 as well). Doing it by hand is very hard!</li>
            <li>Are KD-Tree lookups parallelizable?</li>
        </ul>
    </body>
</html>
